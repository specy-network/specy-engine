// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: EntityQuery.proto

#ifndef PROTOBUF_INCLUDED_EntityQuery_2eproto
#define PROTOBUF_INCLUDED_EntityQuery_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_EntityQuery_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_EntityQuery_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_EntityQuery_2eproto();
namespace rule_check_proto {
class Constraint;
class ConstraintDefaultTypeInternal;
extern ConstraintDefaultTypeInternal _Constraint_default_instance_;
class Provided;
class ProvidedDefaultTypeInternal;
extern ProvidedDefaultTypeInternal _Provided_default_instance_;
class Where;
class WhereDefaultTypeInternal;
extern WhereDefaultTypeInternal _Where_default_instance_;
class Within;
class WithinDefaultTypeInternal;
extern WithinDefaultTypeInternal _Within_default_instance_;
}  // namespace rule_check_proto
namespace google {
namespace protobuf {
template<> ::rule_check_proto::Constraint* Arena::CreateMaybeMessage<::rule_check_proto::Constraint>(Arena*);
template<> ::rule_check_proto::Provided* Arena::CreateMaybeMessage<::rule_check_proto::Provided>(Arena*);
template<> ::rule_check_proto::Where* Arena::CreateMaybeMessage<::rule_check_proto::Where>(Arena*);
template<> ::rule_check_proto::Within* Arena::CreateMaybeMessage<::rule_check_proto::Within>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace rule_check_proto {

enum Within_UNIT {
  Within_UNIT_SEC = 0,
  Within_UNIT_MINIT = 1,
  Within_UNIT_HOUR = 2,
  Within_UNIT_DAY = 3,
  Within_UNIT_Within_UNIT_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Within_UNIT_Within_UNIT_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Within_UNIT_IsValid(int value);
const Within_UNIT Within_UNIT_UNIT_MIN = Within_UNIT_SEC;
const Within_UNIT Within_UNIT_UNIT_MAX = Within_UNIT_DAY;
const int Within_UNIT_UNIT_ARRAYSIZE = Within_UNIT_UNIT_MAX + 1;

const ::google::protobuf::EnumDescriptor* Within_UNIT_descriptor();
inline const ::std::string& Within_UNIT_Name(Within_UNIT value) {
  return ::google::protobuf::internal::NameOfEnum(
    Within_UNIT_descriptor(), value);
}
inline bool Within_UNIT_Parse(
    const ::std::string& name, Within_UNIT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Within_UNIT>(
    Within_UNIT_descriptor(), name, value);
}
enum Where_OPERATOR {
  Where_OPERATOR_EQ = 0,
  Where_OPERATOR_NEQ = 1,
  Where_OPERATOR_GT = 2,
  Where_OPERATOR_LT = 3,
  Where_OPERATOR_EGT = 4,
  Where_OPERATOR_ELT = 5,
  Where_OPERATOR_Where_OPERATOR_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Where_OPERATOR_Where_OPERATOR_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Where_OPERATOR_IsValid(int value);
const Where_OPERATOR Where_OPERATOR_OPERATOR_MIN = Where_OPERATOR_EQ;
const Where_OPERATOR Where_OPERATOR_OPERATOR_MAX = Where_OPERATOR_ELT;
const int Where_OPERATOR_OPERATOR_ARRAYSIZE = Where_OPERATOR_OPERATOR_MAX + 1;

const ::google::protobuf::EnumDescriptor* Where_OPERATOR_descriptor();
inline const ::std::string& Where_OPERATOR_Name(Where_OPERATOR value) {
  return ::google::protobuf::internal::NameOfEnum(
    Where_OPERATOR_descriptor(), value);
}
inline bool Where_OPERATOR_Parse(
    const ::std::string& name, Where_OPERATOR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Where_OPERATOR>(
    Where_OPERATOR_descriptor(), name, value);
}
// ===================================================================

class Constraint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rule_check_proto.Constraint) */ {
 public:
  Constraint();
  virtual ~Constraint();

  Constraint(const Constraint& from);

  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Constraint(Constraint&& from) noexcept
    : Constraint() {
    *this = ::std::move(from);
  }

  inline Constraint& operator=(Constraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Constraint& default_instance();

  enum ContentCase {
    kProvided = 1,
    kWithin = 2,
    kWhere = 3,
    CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Constraint* internal_default_instance() {
    return reinterpret_cast<const Constraint*>(
               &_Constraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Constraint* other);
  friend void swap(Constraint& a, Constraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Constraint* New() const final {
    return CreateMaybeMessage<Constraint>(nullptr);
  }

  Constraint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Constraint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rule_check_proto.Provided provided = 1;
  bool has_provided() const;
  void clear_provided();
  static const int kProvidedFieldNumber = 1;
  const ::rule_check_proto::Provided& provided() const;
  ::rule_check_proto::Provided* release_provided();
  ::rule_check_proto::Provided* mutable_provided();
  void set_allocated_provided(::rule_check_proto::Provided* provided);

  // .rule_check_proto.Within within = 2;
  bool has_within() const;
  void clear_within();
  static const int kWithinFieldNumber = 2;
  const ::rule_check_proto::Within& within() const;
  ::rule_check_proto::Within* release_within();
  ::rule_check_proto::Within* mutable_within();
  void set_allocated_within(::rule_check_proto::Within* within);

  // .rule_check_proto.Where where = 3;
  bool has_where() const;
  void clear_where();
  static const int kWhereFieldNumber = 3;
  const ::rule_check_proto::Where& where() const;
  ::rule_check_proto::Where* release_where();
  ::rule_check_proto::Where* mutable_where();
  void set_allocated_where(::rule_check_proto::Where* where);

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:rule_check_proto.Constraint)
 private:
  class HasBitSetters;
  void set_has_provided();
  void set_has_within();
  void set_has_where();

  inline bool has_content() const;
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ContentUnion {
    ContentUnion() {}
    ::rule_check_proto::Provided* provided_;
    ::rule_check_proto::Within* within_;
    ::rule_check_proto::Where* where_;
  } content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_EntityQuery_2eproto;
};
// -------------------------------------------------------------------

class Provided :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rule_check_proto.Provided) */ {
 public:
  Provided();
  virtual ~Provided();

  Provided(const Provided& from);

  inline Provided& operator=(const Provided& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Provided(Provided&& from) noexcept
    : Provided() {
    *this = ::std::move(from);
  }

  inline Provided& operator=(Provided&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Provided& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Provided* internal_default_instance() {
    return reinterpret_cast<const Provided*>(
               &_Provided_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Provided* other);
  friend void swap(Provided& a, Provided& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Provided* New() const final {
    return CreateMaybeMessage<Provided>(nullptr);
  }

  Provided* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Provided>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Provided& from);
  void MergeFrom(const Provided& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Provided* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string entity = 1;
  void clear_entity();
  static const int kEntityFieldNumber = 1;
  const ::std::string& entity() const;
  void set_entity(const ::std::string& value);
  #if LANG_CXX11
  void set_entity(::std::string&& value);
  #endif
  void set_entity(const char* value);
  void set_entity(const char* value, size_t size);
  ::std::string* mutable_entity();
  ::std::string* release_entity();
  void set_allocated_entity(::std::string* entity);

  // string member = 2;
  void clear_member();
  static const int kMemberFieldNumber = 2;
  const ::std::string& member() const;
  void set_member(const ::std::string& value);
  #if LANG_CXX11
  void set_member(::std::string&& value);
  #endif
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  ::std::string* mutable_member();
  ::std::string* release_member();
  void set_allocated_member(::std::string* member);

  // @@protoc_insertion_point(class_scope:rule_check_proto.Provided)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr entity_;
  ::google::protobuf::internal::ArenaStringPtr member_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_EntityQuery_2eproto;
};
// -------------------------------------------------------------------

class Within :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rule_check_proto.Within) */ {
 public:
  Within();
  virtual ~Within();

  Within(const Within& from);

  inline Within& operator=(const Within& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Within(Within&& from) noexcept
    : Within() {
    *this = ::std::move(from);
  }

  inline Within& operator=(Within&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Within& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Within* internal_default_instance() {
    return reinterpret_cast<const Within*>(
               &_Within_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Within* other);
  friend void swap(Within& a, Within& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Within* New() const final {
    return CreateMaybeMessage<Within>(nullptr);
  }

  Within* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Within>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Within& from);
  void MergeFrom(const Within& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Within* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Within_UNIT UNIT;
  static const UNIT SEC =
    Within_UNIT_SEC;
  static const UNIT MINIT =
    Within_UNIT_MINIT;
  static const UNIT HOUR =
    Within_UNIT_HOUR;
  static const UNIT DAY =
    Within_UNIT_DAY;
  static inline bool UNIT_IsValid(int value) {
    return Within_UNIT_IsValid(value);
  }
  static const UNIT UNIT_MIN =
    Within_UNIT_UNIT_MIN;
  static const UNIT UNIT_MAX =
    Within_UNIT_UNIT_MAX;
  static const int UNIT_ARRAYSIZE =
    Within_UNIT_UNIT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UNIT_descriptor() {
    return Within_UNIT_descriptor();
  }
  static inline const ::std::string& UNIT_Name(UNIT value) {
    return Within_UNIT_Name(value);
  }
  static inline bool UNIT_Parse(const ::std::string& name,
      UNIT* value) {
    return Within_UNIT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // uint64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // .rule_check_proto.Within.UNIT unit = 2;
  void clear_unit();
  static const int kUnitFieldNumber = 2;
  ::rule_check_proto::Within_UNIT unit() const;
  void set_unit(::rule_check_proto::Within_UNIT value);

  // @@protoc_insertion_point(class_scope:rule_check_proto.Within)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 value_;
  int unit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_EntityQuery_2eproto;
};
// -------------------------------------------------------------------

class Where :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rule_check_proto.Where) */ {
 public:
  Where();
  virtual ~Where();

  Where(const Where& from);

  inline Where& operator=(const Where& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Where(Where&& from) noexcept
    : Where() {
    *this = ::std::move(from);
  }

  inline Where& operator=(Where&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Where& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Where* internal_default_instance() {
    return reinterpret_cast<const Where*>(
               &_Where_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Where* other);
  friend void swap(Where& a, Where& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Where* New() const final {
    return CreateMaybeMessage<Where>(nullptr);
  }

  Where* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Where>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Where& from);
  void MergeFrom(const Where& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Where* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Where_OPERATOR OPERATOR;
  static const OPERATOR EQ =
    Where_OPERATOR_EQ;
  static const OPERATOR NEQ =
    Where_OPERATOR_NEQ;
  static const OPERATOR GT =
    Where_OPERATOR_GT;
  static const OPERATOR LT =
    Where_OPERATOR_LT;
  static const OPERATOR EGT =
    Where_OPERATOR_EGT;
  static const OPERATOR ELT =
    Where_OPERATOR_ELT;
  static inline bool OPERATOR_IsValid(int value) {
    return Where_OPERATOR_IsValid(value);
  }
  static const OPERATOR OPERATOR_MIN =
    Where_OPERATOR_OPERATOR_MIN;
  static const OPERATOR OPERATOR_MAX =
    Where_OPERATOR_OPERATOR_MAX;
  static const int OPERATOR_ARRAYSIZE =
    Where_OPERATOR_OPERATOR_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATOR_descriptor() {
    return Where_OPERATOR_descriptor();
  }
  static inline const ::std::string& OPERATOR_Name(OPERATOR value) {
    return Where_OPERATOR_Name(value);
  }
  static inline bool OPERATOR_Parse(const ::std::string& name,
      OPERATOR* value) {
    return Where_OPERATOR_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string left_entity = 1;
  void clear_left_entity();
  static const int kLeftEntityFieldNumber = 1;
  const ::std::string& left_entity() const;
  void set_left_entity(const ::std::string& value);
  #if LANG_CXX11
  void set_left_entity(::std::string&& value);
  #endif
  void set_left_entity(const char* value);
  void set_left_entity(const char* value, size_t size);
  ::std::string* mutable_left_entity();
  ::std::string* release_left_entity();
  void set_allocated_left_entity(::std::string* left_entity);

  // string left_member = 2;
  void clear_left_member();
  static const int kLeftMemberFieldNumber = 2;
  const ::std::string& left_member() const;
  void set_left_member(const ::std::string& value);
  #if LANG_CXX11
  void set_left_member(::std::string&& value);
  #endif
  void set_left_member(const char* value);
  void set_left_member(const char* value, size_t size);
  ::std::string* mutable_left_member();
  ::std::string* release_left_member();
  void set_allocated_left_member(::std::string* left_member);

  // string right_entity = 4;
  void clear_right_entity();
  static const int kRightEntityFieldNumber = 4;
  const ::std::string& right_entity() const;
  void set_right_entity(const ::std::string& value);
  #if LANG_CXX11
  void set_right_entity(::std::string&& value);
  #endif
  void set_right_entity(const char* value);
  void set_right_entity(const char* value, size_t size);
  ::std::string* mutable_right_entity();
  ::std::string* release_right_entity();
  void set_allocated_right_entity(::std::string* right_entity);

  // string right_member = 5;
  void clear_right_member();
  static const int kRightMemberFieldNumber = 5;
  const ::std::string& right_member() const;
  void set_right_member(const ::std::string& value);
  #if LANG_CXX11
  void set_right_member(::std::string&& value);
  #endif
  void set_right_member(const char* value);
  void set_right_member(const char* value, size_t size);
  ::std::string* mutable_right_member();
  ::std::string* release_right_member();
  void set_allocated_right_member(::std::string* right_member);

  // .rule_check_proto.Where.OPERATOR operator = 3;
  void clear_operator_();
  static const int kOperatorFieldNumber = 3;
  ::rule_check_proto::Where_OPERATOR operator_() const;
  void set_operator_(::rule_check_proto::Where_OPERATOR value);

  // @@protoc_insertion_point(class_scope:rule_check_proto.Where)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr left_entity_;
  ::google::protobuf::internal::ArenaStringPtr left_member_;
  ::google::protobuf::internal::ArenaStringPtr right_entity_;
  ::google::protobuf::internal::ArenaStringPtr right_member_;
  int operator__;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_EntityQuery_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Constraint

// .rule_check_proto.Provided provided = 1;
inline bool Constraint::has_provided() const {
  return content_case() == kProvided;
}
inline void Constraint::set_has_provided() {
  _oneof_case_[0] = kProvided;
}
inline void Constraint::clear_provided() {
  if (has_provided()) {
    delete content_.provided_;
    clear_has_content();
  }
}
inline ::rule_check_proto::Provided* Constraint::release_provided() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Constraint.provided)
  if (has_provided()) {
    clear_has_content();
      ::rule_check_proto::Provided* temp = content_.provided_;
    content_.provided_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rule_check_proto::Provided& Constraint::provided() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Constraint.provided)
  return has_provided()
      ? *content_.provided_
      : *reinterpret_cast< ::rule_check_proto::Provided*>(&::rule_check_proto::_Provided_default_instance_);
}
inline ::rule_check_proto::Provided* Constraint::mutable_provided() {
  if (!has_provided()) {
    clear_content();
    set_has_provided();
    content_.provided_ = CreateMaybeMessage< ::rule_check_proto::Provided >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Constraint.provided)
  return content_.provided_;
}

// .rule_check_proto.Within within = 2;
inline bool Constraint::has_within() const {
  return content_case() == kWithin;
}
inline void Constraint::set_has_within() {
  _oneof_case_[0] = kWithin;
}
inline void Constraint::clear_within() {
  if (has_within()) {
    delete content_.within_;
    clear_has_content();
  }
}
inline ::rule_check_proto::Within* Constraint::release_within() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Constraint.within)
  if (has_within()) {
    clear_has_content();
      ::rule_check_proto::Within* temp = content_.within_;
    content_.within_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rule_check_proto::Within& Constraint::within() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Constraint.within)
  return has_within()
      ? *content_.within_
      : *reinterpret_cast< ::rule_check_proto::Within*>(&::rule_check_proto::_Within_default_instance_);
}
inline ::rule_check_proto::Within* Constraint::mutable_within() {
  if (!has_within()) {
    clear_content();
    set_has_within();
    content_.within_ = CreateMaybeMessage< ::rule_check_proto::Within >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Constraint.within)
  return content_.within_;
}

// .rule_check_proto.Where where = 3;
inline bool Constraint::has_where() const {
  return content_case() == kWhere;
}
inline void Constraint::set_has_where() {
  _oneof_case_[0] = kWhere;
}
inline void Constraint::clear_where() {
  if (has_where()) {
    delete content_.where_;
    clear_has_content();
  }
}
inline ::rule_check_proto::Where* Constraint::release_where() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Constraint.where)
  if (has_where()) {
    clear_has_content();
      ::rule_check_proto::Where* temp = content_.where_;
    content_.where_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rule_check_proto::Where& Constraint::where() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Constraint.where)
  return has_where()
      ? *content_.where_
      : *reinterpret_cast< ::rule_check_proto::Where*>(&::rule_check_proto::_Where_default_instance_);
}
inline ::rule_check_proto::Where* Constraint::mutable_where() {
  if (!has_where()) {
    clear_content();
    set_has_where();
    content_.where_ = CreateMaybeMessage< ::rule_check_proto::Where >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Constraint.where)
  return content_.where_;
}

inline bool Constraint::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Constraint::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Constraint::ContentCase Constraint::content_case() const {
  return Constraint::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Provided

// string entity = 1;
inline void Provided::clear_entity() {
  entity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Provided::entity() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Provided.entity)
  return entity_.GetNoArena();
}
inline void Provided::set_entity(const ::std::string& value) {
  
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Provided.entity)
}
#if LANG_CXX11
inline void Provided::set_entity(::std::string&& value) {
  
  entity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Provided.entity)
}
#endif
inline void Provided::set_entity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Provided.entity)
}
inline void Provided::set_entity(const char* value, size_t size) {
  
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Provided.entity)
}
inline ::std::string* Provided::mutable_entity() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Provided.entity)
  return entity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Provided::release_entity() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Provided.entity)
  
  return entity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Provided::set_allocated_entity(::std::string* entity) {
  if (entity != nullptr) {
    
  } else {
    
  }
  entity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entity);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Provided.entity)
}

// string member = 2;
inline void Provided::clear_member() {
  member_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Provided::member() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Provided.member)
  return member_.GetNoArena();
}
inline void Provided::set_member(const ::std::string& value) {
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Provided.member)
}
#if LANG_CXX11
inline void Provided::set_member(::std::string&& value) {
  
  member_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Provided.member)
}
#endif
inline void Provided::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Provided.member)
}
inline void Provided::set_member(const char* value, size_t size) {
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Provided.member)
}
inline ::std::string* Provided::mutable_member() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Provided.member)
  return member_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Provided::release_member() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Provided.member)
  
  return member_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Provided::set_allocated_member(::std::string* member) {
  if (member != nullptr) {
    
  } else {
    
  }
  member_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Provided.member)
}

// -------------------------------------------------------------------

// Within

// uint64 value = 1;
inline void Within::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Within::value() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Within.value)
  return value_;
}
inline void Within::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:rule_check_proto.Within.value)
}

// .rule_check_proto.Within.UNIT unit = 2;
inline void Within::clear_unit() {
  unit_ = 0;
}
inline ::rule_check_proto::Within_UNIT Within::unit() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Within.unit)
  return static_cast< ::rule_check_proto::Within_UNIT >(unit_);
}
inline void Within::set_unit(::rule_check_proto::Within_UNIT value) {
  
  unit_ = value;
  // @@protoc_insertion_point(field_set:rule_check_proto.Within.unit)
}

// -------------------------------------------------------------------

// Where

// string left_entity = 1;
inline void Where::clear_left_entity() {
  left_entity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Where::left_entity() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Where.left_entity)
  return left_entity_.GetNoArena();
}
inline void Where::set_left_entity(const ::std::string& value) {
  
  left_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Where.left_entity)
}
#if LANG_CXX11
inline void Where::set_left_entity(::std::string&& value) {
  
  left_entity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Where.left_entity)
}
#endif
inline void Where::set_left_entity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  left_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Where.left_entity)
}
inline void Where::set_left_entity(const char* value, size_t size) {
  
  left_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Where.left_entity)
}
inline ::std::string* Where::mutable_left_entity() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Where.left_entity)
  return left_entity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Where::release_left_entity() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Where.left_entity)
  
  return left_entity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Where::set_allocated_left_entity(::std::string* left_entity) {
  if (left_entity != nullptr) {
    
  } else {
    
  }
  left_entity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), left_entity);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Where.left_entity)
}

// string left_member = 2;
inline void Where::clear_left_member() {
  left_member_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Where::left_member() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Where.left_member)
  return left_member_.GetNoArena();
}
inline void Where::set_left_member(const ::std::string& value) {
  
  left_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Where.left_member)
}
#if LANG_CXX11
inline void Where::set_left_member(::std::string&& value) {
  
  left_member_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Where.left_member)
}
#endif
inline void Where::set_left_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  left_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Where.left_member)
}
inline void Where::set_left_member(const char* value, size_t size) {
  
  left_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Where.left_member)
}
inline ::std::string* Where::mutable_left_member() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Where.left_member)
  return left_member_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Where::release_left_member() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Where.left_member)
  
  return left_member_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Where::set_allocated_left_member(::std::string* left_member) {
  if (left_member != nullptr) {
    
  } else {
    
  }
  left_member_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), left_member);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Where.left_member)
}

// .rule_check_proto.Where.OPERATOR operator = 3;
inline void Where::clear_operator_() {
  operator__ = 0;
}
inline ::rule_check_proto::Where_OPERATOR Where::operator_() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Where.operator)
  return static_cast< ::rule_check_proto::Where_OPERATOR >(operator__);
}
inline void Where::set_operator_(::rule_check_proto::Where_OPERATOR value) {
  
  operator__ = value;
  // @@protoc_insertion_point(field_set:rule_check_proto.Where.operator)
}

// string right_entity = 4;
inline void Where::clear_right_entity() {
  right_entity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Where::right_entity() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Where.right_entity)
  return right_entity_.GetNoArena();
}
inline void Where::set_right_entity(const ::std::string& value) {
  
  right_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Where.right_entity)
}
#if LANG_CXX11
inline void Where::set_right_entity(::std::string&& value) {
  
  right_entity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Where.right_entity)
}
#endif
inline void Where::set_right_entity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  right_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Where.right_entity)
}
inline void Where::set_right_entity(const char* value, size_t size) {
  
  right_entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Where.right_entity)
}
inline ::std::string* Where::mutable_right_entity() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Where.right_entity)
  return right_entity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Where::release_right_entity() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Where.right_entity)
  
  return right_entity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Where::set_allocated_right_entity(::std::string* right_entity) {
  if (right_entity != nullptr) {
    
  } else {
    
  }
  right_entity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), right_entity);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Where.right_entity)
}

// string right_member = 5;
inline void Where::clear_right_member() {
  right_member_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Where::right_member() const {
  // @@protoc_insertion_point(field_get:rule_check_proto.Where.right_member)
  return right_member_.GetNoArena();
}
inline void Where::set_right_member(const ::std::string& value) {
  
  right_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rule_check_proto.Where.right_member)
}
#if LANG_CXX11
inline void Where::set_right_member(::std::string&& value) {
  
  right_member_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rule_check_proto.Where.right_member)
}
#endif
inline void Where::set_right_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  right_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rule_check_proto.Where.right_member)
}
inline void Where::set_right_member(const char* value, size_t size) {
  
  right_member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rule_check_proto.Where.right_member)
}
inline ::std::string* Where::mutable_right_member() {
  
  // @@protoc_insertion_point(field_mutable:rule_check_proto.Where.right_member)
  return right_member_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Where::release_right_member() {
  // @@protoc_insertion_point(field_release:rule_check_proto.Where.right_member)
  
  return right_member_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Where::set_allocated_right_member(::std::string* right_member) {
  if (right_member != nullptr) {
    
  } else {
    
  }
  right_member_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), right_member);
  // @@protoc_insertion_point(field_set_allocated:rule_check_proto.Where.right_member)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rule_check_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::rule_check_proto::Within_UNIT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rule_check_proto::Within_UNIT>() {
  return ::rule_check_proto::Within_UNIT_descriptor();
}
template <> struct is_proto_enum< ::rule_check_proto::Where_OPERATOR> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rule_check_proto::Where_OPERATOR>() {
  return ::rule_check_proto::Where_OPERATOR_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_EntityQuery_2eproto
